<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>QuantumClash 3D Fixed</title>
<style>
body { margin:0; overflow:hidden; background:#111; font-family:Arial,sans-serif; }
canvas { position:fixed; top:0; left:0; z-index:1; }
header { position:fixed; top:0; width:100%; padding:12px; background:#0ff; color:#111; font-weight:bold; text-align:center; z-index:10; }
#ui { position:fixed; top:60px; left:10px; color:#0ff; z-index:10; }
#ui div { margin-bottom:6px; }
</style>
</head>
<body>

<header>QuantumClash 3D Fixed</header>

<div id="ui">
  <div id="score">Score: 0</div>
  <div id="p1">Player1 Health: 100</div>
  <div id="p2">Player2 Health: 100</div>
  <div id="boss">Boss Health: 200</div>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/controls/OrbitControls.js";
import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/loaders/GLTFLoader.js";

/* ===== SCENE SETUP ===== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 15, 25);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableRotate = false;
controls.enablePan = false;

/* ===== LIGHTS ===== */
scene.add(new THREE.AmbientLight(0xffffff, 1.2));
const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(10,20,10);
scene.add(dirLight);

/* ===== FLOOR ===== */
const floor = new THREE.Mesh(new THREE.PlaneGeometry(60,60), new THREE.MeshStandardMaterial({color:0x222222}));
floor.rotation.x = -Math.PI/2;
scene.add(floor);

/* ===== VARIABLES ===== */
const loader = new GLTFLoader();
let player1, player2, boss, enemyModel;
let bullets = [], enemies = [], shields = [];
let score = 0, p1Health = 100, p2Health = 100, bossHealth = 200;
const keys = {};

/* ===== LOAD MODELS (CORS-ENABLED) ===== */
function loadModel(url){
  return new Promise((resolve,reject)=>{
    loader.load(url, gltf=>resolve(gltf.scene), undefined, err=>reject(err));
  });
}

const modelURL = "https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb";

Promise.all([
  loadModel(modelURL), // player1
  loadModel(modelURL), // player2
  loadModel(modelURL), // boss
  loadModel(modelURL)  // enemy template
]).then(models=>{
  [player1, player2, boss, enemyModel] = models;

  player1.scale.set(2,2,2); player1.position.set(-5,0,0); scene.add(player1);
  player2.scale.set(2,2,2); player2.position.set(5,0,0); scene.add(player2);
  boss.scale.set(3,3,3); boss.position.set(0,0,-15); scene.add(boss);

  animate();
}).catch(err => console.error("Model loading error:", err));

/* ===== SPAWN ENEMY ===== */
function spawnEnemy(){
  if(!enemyModel) return;
  let e = enemyModel.clone();
  e.scale.set(1.5,1.5,1.5);
  e.position.set(Math.random()*20-10,0,Math.random()*-20);
  scene.add(e);
  enemies.push(e);
}
setInterval(spawnEnemy,7000);

/* ===== BULLETS ===== */
function shootBullet(player){
  if(!player) return;
  let b = new THREE.Mesh(new THREE.SphereGeometry(0.2,8,8), new THREE.MeshStandardMaterial({color:0xffff00, emissive:0xffff00}));
  b.position.copy(player.position).add(new THREE.Vector3(0,1,0));
  b.owner = player;
  scene.add(b);
  bullets.push(b);
}

/* ===== SHIELDS ===== */
function activateShield(player){
  if(!player) return;
  let s = new THREE.Mesh(new THREE.SphereGeometry(1.5,16,16), new THREE.MeshStandardMaterial({color:0x00ffff, transparent:true, opacity:0.4}));
  s.position.copy(player.position);
  s.owner = player;
  scene.add(s);
  shields.push(s);
  setTimeout(()=>{scene.remove(s); shields.splice(shields.indexOf(s),1);},3000);
}

/* ===== INPUT ===== */
document.addEventListener("keydown", e=>{
  keys[e.key.toLowerCase()] = true;
  if(e.key===' ') shootBullet(player1);
  if(e.key==='Enter') shootBullet(player2);
  if(e.key==='q') activateShield(player1);
  if(e.key==='/') activateShield(player2);
});
document.addEventListener("keyup", e=>{
  keys[e.key.toLowerCase()] = false;
});

/* ===== UI ===== */
const scoreEl = document.getElementById("score");
const p1El = document.getElementById("p1");
const p2El = document.getElementById("p2");
const bossEl = document.getElementById("boss");
function updateUI(){
  scoreEl.textContent = "Score: "+score;
  p1El.textContent = "Player1 Health: "+p1Health;
  p2El.textContent = "Player2 Health: "+p2Health;
  bossEl.textContent = "Boss Health: "+bossHealth;
}

/* ===== ANIMATION LOOP ===== */
function animate(){
  requestAnimationFrame(animate);

  if(player1){
    if(keys["w"]) player1.position.z -=0.2;
    if(keys["s"]) player1.position.z +=0.2;
    if(keys["a"]) player1.position.x -=0.2;
    if(keys["d"]) player1.position.x +=0.2;
  }
  if(player2){
    if(keys["arrowup"]) player2.position.z -=0.2;
    if(keys["arrowdown"]) player2.position.z +=0.2;
    if(keys["arrowleft"]) player2.position.x -=0.2;
    if(keys["arrowright"]) player2.position.x +=0.2;
  }

  // Move bullets backward loop
  for(let i=bullets.length-1;i>=0;i--){
    let b = bullets[i];
    b.position.z -= 0.5;

    // Check enemies
    for(let j=enemies.length-1;j>=0;j--){
      let e = enemies[j];
      if(b.position.distanceTo(e.position)<1){
        scene.remove(b); scene.remove(e);
        bullets.splice(i,1);
        enemies.splice(j,1);
        score += 10;
        break;
      }
    }

    // Check boss
    if(boss && b.position.distanceTo(boss.position)<2){
      bossHealth -= 10; score += 20;
      scene.remove(b); bullets.splice(i,1);
      if(bossHealth<=0) scene.remove(boss);
    }
  }

  // Shields follow players
  shields.forEach(s=>s.position.copy(s.owner.position));

  updateUI();
  renderer.render(scene,camera);
}

/* ===== WINDOW RESIZE ===== */
window.addEventListener("resize", ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>

